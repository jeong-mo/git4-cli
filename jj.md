# 프로세스(Process)란?
메모리에 적재되어 CPU에서 실행중인 프로그램

### 구성요소 

<img src="https://velog.velcdn.com/images/boyfromthewell/post/aff3ce32-ae0a-416c-8256-75d98ff714c3/image.png" width="30%" height="30">

1. 컴파일된 프로그램 코드
2. 프로그램 카운터 (PC) - 다음에 실행될 명령어 포인터
3. CPU 레지스터 내용
4. 프로세스 stack
5. 데이터 섹션
6. Heap (개발자가 필요에 의해 동적으로 할당하는 메모리)

## 프로세스 상태
1. New : 프로세스 생성중
2. Running : CPU에서 명령이 실행중
3. Waiting : 프로세스가 CPU에 할당되어 실행 대기중
4. Ready : 프로세스가 CPU에 할당되어 실행 대기중
5. Terminated : 프로세스 실행 종료

>(CPU는 여러개의 프로세스를 동시에 수행이 불가능하다. 운영체제의 멀티 태스킹과 스케줄링 기법으로 여러개가 동시 실행 되는것으로 보일뿐이다.)

![](https://velog.velcdn.com/images/boyfromthewell/post/79923217-1eca-4471-9ff6-15bb69fbf2af/image.png)

* **new -> ready -> running**
프로세스가 생성되면 바로 running 상태로 가는것이 아닌 ready 상태, 스케줄링 기법에 따라 1개만 running으로 바뀔수 있다.

* **running -> waiting -> ready**
계속 실행되는것이 아닌 어떤 조건이 만족되면 상태가 변경된다.
_ex) scanf, printf.... 이 작업들은 매우 느리기 떄문에 상태를 waiting으로 바꾸는데 ,waiting event가 끝나기 위해선 I/O 이벤트 완료 인터럽트가 와야한다. 이 인터럽트가 발생되면 다시 ready 상태로 돌아간다._

* **running -> exit**
running상태에 있던 프로세스 종료

* **running -> ready -> running -> ready....**
1ms~10ms 마다 타이머 인터럽트가 발생, 운영체제는 현재 실행중 프로세스를 강제로 종료시키고 ready 상태에 있는 다른 프로세스를 실행 시킨다. 이 과정은 매우 빠르기 때문에 마치 여러개의 프로세스가 1개의 CPU를 가지고 동시에 실행 하는것처럼 보인다.

### 프로세스 제어 블록 (PCB)

프로세스의 실행을 제어하는데 사용하기 위한 자료구조, 프로세스마다 한개씩 할당 된다.
(운영체제가 프로세스에 대한 중요한 정보를 저장 해놓는곳이라 생각하면 된다.)

#### 구성요소
1. 프로세스 상태
2. 프로그램 카운터(PC)
3. CPU 스케쥴링 정보
4. 메모리
5. 회계 정보
6. 입출력상태

운영체제는 프로세스가 관리되기 위한 필요한 정보를 (PCB) 커널영역에 저장한다.
> 프로세스가 계속 변하더라도 PCB를 이용해 해당 프로세스가 연속적으로 실행 되는것 처럼 보인다.


#### Context Switch (문맥교환)
프로세스 교환을 의미한다. 프로세스 문맥이란 프로세스 제어를 위한 정보를 의미한다. (PCB)

스케쥴러가 CPU에 다른 프로세스를 할당하려 할때 현재 프로세스의 Context를 PCB에 저장, 새로운 프로세스의 PCB 상태값으로 교체하는 작업을 말한다.
